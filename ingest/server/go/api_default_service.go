/*
 * GoBun File Store
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"io"
	"log"
	"math"
	"net/http"
	"os"
	"time"

	"go.formulabun.club/functional/array"
	"go.formulabun.club/replays/store"
	"go.formulabun.club/srb2kart/lump/replay"
)

// DefaultApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
	db store.Client
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	c, err := store.NewClient()
	for err != nil {
		log.Printf("Could not establish database connection %s", err)
		<-time.After(time.Second * 5)
		c, err = store.NewClient()
	}
	log.Print("Database connection established.")
	return &DefaultApiService{c}
}

// ListGet - Get the list of replay files
func (s *DefaultApiService) ListGet(ctx context.Context) (ImplResponse, error) {
	entries, err := os.ReadDir("/data")
	if err != nil {
		return Response(http.StatusInternalServerError, err), err
	}

	files := array.Map(entries, func(entry os.DirEntry) string {
		return entry.Name()
	})

	return Response(http.StatusOK, files), nil
}

// RootPost - Upload a new replay file
func (s *DefaultApiService) RootPost(ctx context.Context, data io.ReadCloser) (ImplResponse, error) {
	header, err := replay.ReadReplay(data)
	if err != nil {
		return Response(http.StatusBadRequest, nil), err
	}

	if header.Time == math.MaxUint32 {
		return Response(http.StatusBadRequest, "this replay is unfinished"), nil
	}

	id, err := s.db.InsertReplayRaw(header)
	if err != nil {
		if store.DuplicateEntryError.Is(err) {
			return Response(http.StatusConflict, "This replay is already present in the database"), fmt.Errorf("Could not save replay to db: %s", err)
		}
		return Response(http.StatusInternalServerError, "Internal Server Error"), fmt.Errorf("Could not save replay to db: %s", err)
	}

	fileName := fmt.Sprintf("/data/%d", id)
	_, err = os.Stat(fileName)
	if err == nil {
		log.Printf("File with path '%s' already exists", fileName)
		return Response(http.StatusConflict, "File already exists"), nil
	}

	file, err := os.Create(fileName)
	if err != nil {
		return Response(http.StatusInternalServerError, "Could not save replay file"), err
	}

	err = header.Write(file)
	if err != nil {
		return Response(http.StatusInternalServerError, "Could not save replay file"), fmt.Errorf("Could not write the replay file: %s", err)
	}

	_, err = io.Copy(file, data)
	if err != nil {
		return Response(http.StatusInternalServerError, "Could not save replay file"), fmt.Errorf("Could not write the replay file: %s", err)
	}

	return Response(http.StatusOK, id), nil
}
